## 自顶向下的编程方法

先将解决框架写出来，然后深入到细节，编写各个子函数。

[自顶向下编程](https://www.markhneedham.com/blog/2008/09/15/clean-code-book-review/)

```javascript
function isPalindrome(s) {
  // 1. filter out number & char 2. reverse and compare
  let s = filterOutNumberChar(s);
  let s = reverse(s)
  function filterOutNumberChar(s) {return s}
  function reverse(s) {return s}
}
```

## 刷题方法

1. 一定要多刷5遍

## 解题方法

1. 审题，确保对题目完全理解。
2. 对题目进行分类，确定考察的知识点。
3. 自顶向下编程，写出框架。
4. 完善细节。
5. 构造各种边界case，进行测试。
6.  看题解，找好的解法（中英文网站）

## 算法复杂度

> 算法的运行速度并非时间，而是操作数的**增速**。  
>
>  谈论算法速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。  
>
>  算法的运行时间用大O表示法表示

常见算法复杂度主要有以下几种，可以根据[主理论](https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86)

| 复杂度   | 常见算法                    |
| -------- | --------------------------- |
| O(1)     | 只执行有限次的常数次        |
| O(logn)  | 二分查找                    |
| O(n)     | 一次for循环(线性时间复杂度) |
| O(nlogn) | 快速排序                    |
| O(n^2)   | 嵌套两次循环                |
| O(2^n)   |                             |
| O(n!)    |                             |

 ## 数组（Array)

### 复杂度

数组是在内存中开辟一段连续的空间，访问数组中的任何元素的复杂度都为O(1)。

| 操作              | 时间复杂度 |
| ----------------- | ---------- |
| 随机访问(arr[68]) | O(1)       |
| 随机插入元素      | O(n)       |
| 随机删除元素      | O(n)       |

### 常见解题方法

#### 双指针

##### 快慢指针

##### 首尾指针

## 链表（Linked List)

分为单向链表和双向链表以及循环链表。

工程应用：LRU Cache

| 操作         | 时间复杂度 |
| ------------ | ---------- |
| 随机访问     | O(n)       |
| 随机插入元素 | O(1)       |
| 随机删除元素 | O(1)       |

## 跳表（战略性放弃）

## 栈（stack & FILO)

具有最近相关性的，则可以使用栈来解决。

## 队列（Queue & FIFO  )

先来后到，FIFO